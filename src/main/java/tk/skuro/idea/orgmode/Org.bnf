/**
 *    Grammar for Org Mode!
 *
 * @author Adriean Khisbe
 *
 * Made following the orgmode syntax draft. (copy in the repo)
 */

/*
 * Notes from Haskell.bnf of Cary M. Robbins
 *
 * WARNING: BE CAREFUL WITH PERFORMANCE WHEN EDITING THIS FILE.
 *
 * Pinning might alter what the parser accepts.
 * Mental model: red cut in logic programming.
 *
 * The parser test suite itself with 40 small examples can literally take 500%
 * longer time. -> §todo
 *
 *
 * Useful patterns and anti-patterns:
 *
 * Good: private impdecls ::= impdecl [semi impdecls]
 *
 * Bad: private impdecls ::= impdecl semi impdecls
 *                        | impdecls
 *
 * Good: funorpatdecl ::= (funlhs | pat) rhs
 *
 * Bad: funorpatdecl ::= funlhs rhs
 *                    | pat rhs
 */

{
    /** Params code généré */
    parserClass="tk.skuro.idea.orgmode.parser.OrgParser"
    // parserUtilClass For external rules
       
    implements="tk.skuro.idea.orgmode.psi.OrgCompositeElement"
    extends="tk.skuro.idea.orgmode.psi.impl.OrgCompositeElementImpl"

    psiClassPrefix="Org"
    psiImplClassSuffix="Impl"
    psiPackage="tk.skuro.idea.orgmode.psi"
    psiImplPackage="tk.skuro.idea.orgmode.psi.impl"

    elementTypeHolderClass="tk.skuro.idea.orgmode.psi.OrgTypes" // file is generated!
    elementTypeClass="tk.skuro.idea.orgmode.psi.OrgElementType"
    tokenTypeClass="tk.skuro.idea.orgmode.psi.OrgTokenType"
      
    psiImplUtilClass="tk.skuro.idea.orgmode.psi.impl.OrgPsiImplUtil"

    /*
         Specific Implem for specific ast node
        implements/extends argument refer to rules
    */
    // implements("varid|conid")="com.haskforce.psi.HaskellNamedElement"

    // TODO: reuse for source block :)
    // implements("qqblob")="com.intellij.psi.PsiLanguageInjectionHost"
    // extends("varid|conid")="com.haskforce.psi.impl.HaskellNamedStubbedPsiElementBase<?>"
    // elementTypeFactory("varid|conid")="com.haskforce.psi.impl.HaskellElementTypeFactory.factory"
       
    generate=[tokenAccessors="yes"]
      
       
       
    /** Tokens **/
    // TODO: add more
    // FIXME: look for token precendence
    tokens=[
      newline="regexp:[\r\n]"
      space='regexp:[ \f\t]+'
      leading_stars="regexp:^\*+ "
      comment_opening="regexp:^[ \f\t]+# "
      leading_whitespace="regexp:^[ \f\t]*"

      keyword="regexp:^[ \f\t]*#+[A-Z_a-z]+:?"
      word="regexp:\S+" //TO impr!!
      number="regexp:\d+"

    ]
         
}

//TODO; search whitespace significant in GK : voir comment découper token ren prenant compte fin de ligne
         
/** DEFINITIONS!!  */

document ::= section? headline*

headline ::= header section? headline*

//////
header ::= leading_stars [ header_keyword space] [ header_priority space] title [ tags ] newline

leading_stars ::= "regexp:^\*+ "
// todo: check non match. (en gros: niveau un de * titi à * toto
header_keyword ::= "TODO"
header_priority ::= '[#' ']' //TODO: choice in list
title ::=   (word | space )+
tags ::= ':'( "regexp:[[:alnum:]_@#%]+" ':')+ //todo: see how to retrieve value

section ::= (element | newline)+
element ::= paragraph | affiliated_keyword | comments | code_ligne

comments ::= (comment newline?)+ //todo: see how to block group them?
// TOFIX: endof file!
comment ::= comment_opening  (word|space)+

affiliated_keyword ::= '#+' "regexp:[A-Za-z]+" ':' [' ']  "regexp:[^\r\n]+" newline//todo: later, use object
// not: afialted, suposed tro be only for list, img.... for now all the "#+KEYWORD

code_ligne ::= leading_whitespace ':' "regexp:[^\r\n]+" // ¤ask: good using token?

paragraph ::= (object| space)+ newline newline*
// maybe extract new line separaot

object ::= word //"regexp:[[:alnum:]_@#%]+" //TO imporove

// TODO: dispatch later
/* Greater Elements  */
         

/* Elements          */
    
    
/* Objects           */
         
